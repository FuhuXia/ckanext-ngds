#!/bin/bash
#
#
#
#
# A few notes on logging
#   * echo commands are written to the console and logged to $logfile
#     simultaneously via the tee command ('| tee -a $logfile').
#   * commands that are logged have both their stdout and stderr
#     written to $logfile via redirection ('&>>$logfile')

this_script=`basename $0`

# The configuration file passed in as param to this script.
config_file=

#
# print_help
#
function print_help () {
    cat <<EOHELP
Use $this_script to install NGDS and components upon which it depends.  Note
that this script requires administrative privileges to install various 
components.

[sudo] $this_script -f <configuration file>

where <configuration file> is a file containing configuration details. For
details about the parameters contained in this file see the '-g' option
below.

Alternately, $this_script can be invoked with the following flags:

-h Displays this help

-g Emits a sample configuration file with explanations of the parameters
   You can customize this file for your particular installation.
EOHELP
}


#
# print_config_file
#
function print_config_file () {
    cat <<EOCONFIG
# NGDS Installation Configuration File
#
# <License details>
#
# <Link to NGDS web site and details>
# 
# Use this file to set the parameters for installing the NGDS web application.

#
# Deployment type
# 
# The web application can be deployed in one of two ways: As a repository
# node, or as an aggregating catalog. The default and typical deployment type
# is the repository node. When deployed this way (by setting deployment_type
# to repository_node) the web application allows the user to upload and share
# their data with the world. When deployed as an aggregating catalog the web
# application harvests the metadata (but not to the data) of registered
# repository nodes and serves as a search engine that spans those nodes.
deployment_type=repository_node
EOCONFIG
}

#
# run_or_die
#
# runs a command and returns if it succeeds; otherwise it exits with
#   the failing command's return value.  Appropriate messages are written.
# params: a command passed in as an unquoted string (exactly as it would be
#   typed on the command line)
# example invocation: run_or_die apt-get install
# assumptions: It is assumed that $logfile is the path to a log file into which
#   to write log messages.
#
function run_or_die {
    if [ -z $logfile ]; then {
        logfile="/dev/null"
    }
    fi
    echo "$this_script: running '$*'" | tee -a $logfile
    # Execute the command and redirect both stdout and stderr to the logfile
    $* &>>$logfile
    # Using tee here causes $? to get the return value of tee, not that of
    # the command itself.
#    $* 2>>$logfile #| tee -a $logfile
    local ret=$?
    if [ $ret -ne 0 ]; then {
        echo "$this_script: '$*' failed." | tee -a $logfile 
        echo "$this_script: See the log file '$logfile' to fix the issue and try again."
        exit $ret
    }
    else {
        echo "$this_script: '$*' succeeded." | tee -a $logfile
        return
    }
    fi
}

# Process command-line arguments
if [ $# -eq 0 ]; then {
    print_help
    exit 0
}
# Or enter interactive mode (not yet implemented)
fi
# (See http://www.gnu.org/software/bash/manual/bashref.html#Shell-Builtin-Commands for getopts)
while getopts ":hf:g" opt; do
    case $opt in
        h)
            print_help
            ;;
        f)
            config_file=$OPTARG
            echo "Using config file $config_file" >&2
            ;;
        g)
            print_config_file
            exit 0
            ;;
        \?)
            echo "Invalid option: -$OPTARG.  Run '$this_script -h' for help." >&2
            exit 1
            ;;
        :)
            echo "Option -$OPTARG requires an argument.  Run '$this_script -h' for help." >&2
            exit 1
            ;;
    esac
done

# Prepare the log file
timestamp=`date +%F_%H-%M`
logfile="log_install-ngds-$timestamp.log"
echo "Writing log into file '$logfile'"
echo "Log file generated by $this_script on $timestamp" > $logfile
chown `whoami` $logfile

# Prepare temporary directory for downloads and the like
tempdir="tmp_install-ngds-$timestamp.tmp"
run_or_die mkdir -p $tempdir

# Based on Ryan's https://github.com/ngds/dev-info/wiki/Ryan-Installs-ckanext-ngds
run_or_die apt-get -y update
run_or_die apt-get -y upgrade
run_or_die apt-get -y install python-dev
run_or_die apt-get -y install postgresql-9.1-postgis
run_or_die apt-get -y install libpq-dev
run_or_die apt-get -y install python-pip
run_or_die apt-get -y install python-virtualenv
run_or_die apt-get -y install git-core

# TODO
# Here we might want to get just the solr WAR file and install it into Tomcat
# instead of having a whole other Java container running.
run_or_die apt-get -y install solr-jetty

# TODO
# Here we might want to try using the Oracle JDK and even adding in the
# native iamging extensions to improve map creation and handling.
# TODO
# What if Oracle's JDK is already installed? Will this install OpenJDK?
# Should we be testing for that?
run_or_die apt-get -y install openjdk-6-jdk

run_or_die apt-get -y install tomcat6
run_or_die apt-get -y install unzip
run_or_die apt-get -y install rabbitmq-server
run_or_die apt-get -y install gdal-bin
run_or_die apt-get -y install build-essential
run_or_die apt-get -y install libxml2-dev
run_or_die apt-get -y install libxslt-dev

# Install geoserver
run_or_die wget -O $tempdir/geoserver-2.3.3-war.zip http://downloads.sourceforge.net/geoserver/geoserver-2.3.3-war.zip
# TODO
# We are not currently handling the case where geoserver.war is already
# installed.  This is important because webapps/geoserver/data contains
# the layer, datastore, and workspace details that GeoServer uses.
# Overwriting these will destroy that data, and those layer will have to
# be recreated.  It is not clear whether overwriting the war file but 
# not deleting the geoserver directory will harm the data.
# TODO
# Do we need to rm -rf /var/lib/tomcat6/webapps/geoserver as part of this
# operation?
run_or_die unzip -d /var/lib/tomcat6/webapps $tempdir/geoserver-2.3.3-war.zip geoserver.war
# TODO
# Configure admin login credentials for GeoServer


# Install CKAN
run_or_die mkdir -p /usr/lib/ckan/default
run_or_die chown `whoami` /usr/lib/ckan/default
run_or_die mkdir -p /etc/ckan
run_or_die virtualenv --no-site-packages /usr/lib/ckan/default
. /usr/lib/ckan/default/bin/activate

# Prepare Database
# TODO
# Handle situation where PostgreSQL is running somewhere other than localhost.

# Note that we are assuming here that this script is being run as root via sudo.
# The expectation is that when root sudo's as postgres, the PostgreSQL commands
# will not prompt for the password of user postgres.
run_or_die sudo -u postgres createdb -E utf8 template_postgis
run_or_die sudo -u postgres psql -d template_postgis -f /usr/share/postgresql/9.1/contrib/postgis-1.5/postgis.sql
run_or_die sudo -u postgres psql -d template_postgis -f /usr/share/postgresql/9.1/contrib/postgis-1.5/spatial_ref_sys.sql

echo "GRANT ALL on geometry_columns to PUBLIC;" > $tempdir/grants_on_template_postgis.sql
echo "GRANT ALL on geography_columns to PUBLIC;" >> $tempdir/grants_on_template_postgis.sql
echo "GRANT ALL on spatial_ref_sys to PUBLIC;" >> $tempdir/grants_on_template_postgis.sql
echo "UPDATE pg_database SET datistemplate='true' WHERE datname='template_postgis';"  >> $tempdir/update_pg_database.sql

run_or_die sudo -u postgres psql -d template_postgis -f $tempdir/grants_on_template_postgis.sql
run_or_die sudo -u postgres psql -d template_postgis -f $tempdir/update_pg_database.sql

# Clean up temporary directory
#run_or_die rm -rf $tempdir

echo "Installation of NGDS is complete." | tee -a $logfile
echo "To start the system ..."
echo "For more information about operating NGDS see the Operations Manual at:"
echo "https://github.com/ngds/dev-info/wiki/NGDS-v1.0-Operations-Guide"

exit
